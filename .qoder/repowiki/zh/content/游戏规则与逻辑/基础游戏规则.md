# 基础游戏规则

<cite>
**Referenced Files in This Document**   
- [useGameState.js](file://src/hooks/useGameState.js)
- [gameUtils.js](file://src/utils/gameUtils.js)
- [gameConstants.js](file://src/constants/gameConstants.js)
</cite>

## 目录
1. [游戏初始化与棋盘结构](#游戏初始化与棋盘结构)
2. [回合机制与玩家控制](#回合机制与玩家控制)
3. [落子合法性校验](#落子合法性校验)
4. [游戏状态管理](#游戏状态管理)
5. [棋盘操作与辅助函数](#棋盘操作与辅助函数)

## 游戏初始化与棋盘结构

五子棋游戏采用标准的15×15棋盘进行对弈。游戏初始化时，系统会创建一个全新的空棋盘，所有位置均未被占用。棋盘的尺寸和获胜条件由`gameConstants.js`中的常量定义，其中`BOARD_SIZE`固定为15，表示棋盘的行数和列数均为15格，而`WIN_COUNT`为5，表示任意一方需要连续放置5枚棋子（横向、纵向或对角线方向）才能获胜。

棋盘的初始化逻辑由`gameUtils.js`中的`createEmptyBoard`函数实现，该函数生成一个15×15的二维数组，每个元素的初始值代表“无棋子”状态。此空棋盘作为游戏的初始状态，为后续的黑白双方落子提供基础。

**Section sources**
- [gameConstants.js](file://src/constants/gameConstants.js#L4-L5)
- [gameUtils.js](file://src/utils/gameUtils.js#L10-L15)

## 回合机制与玩家控制

游戏采用黑白双方交替落子的机制，黑方先行。玩家回合的控制流程由`useGameState.js`中的状态管理Hook负责。游戏开始时，通过`startGame`动作将游戏阶段（`gamePhase`）从`READY`切换至`PLAYING`，并重置当前玩家为黑方（`PLAYER.BLACK`）。

在游戏进行中，每当一方成功落子后，系统会自动触发`switchPlayer`动作，将`currentPlayer`在黑方和白方之间切换，从而实现回合交替。该流程确保了游戏的公平性和有序性。`switchPlayer`函数还集成了对特殊状态（如“冻结”）的检查，如果下一个玩家处于被冻结状态，则其回合将被跳过，直到冻结效果解除。

**Section sources**
- [useGameState.js](file://src/hooks/useGameState.js#L501-L503)
- [useGameState.js](file://src/hooks/useGameState.js#L578-L609)

## 落子合法性校验

落子的合法性是游戏规则的核心，系统通过严格的校验规则来确保每一步操作都符合规范。当玩家尝试在某个位置（x, y）落子时，系统会执行以下校验：

1.  **位置有效性**：首先检查坐标（x, y）是否在15×15的棋盘范围内。
2.  **位置占用性**：其次检查该位置是否为空（`PLAYER.NONE`），确保不会在已有棋子的位置上重复落子。
3.  **玩家状态**：最后检查当前玩家是否处于可行动状态。例如，如果玩家被“静如止水”技能冻结，则无法进行落子。

这些校验逻辑在`useGameState.js`的`PLACE_PIECE`动作中实现。如果任何一项校验失败，该落子请求将被直接忽略，游戏状态保持不变。`isEmptyPosition`等辅助函数由`gameUtils.js`提供，用于高效地执行这些检查。

**Section sources**
- [useGameState.js](file://src/hooks/useGameState.js#L515-L520)
- [gameUtils.js](file://src/utils/gameUtils.js#L26-L39)

## 游戏状态管理

游戏的整个生命周期由`useGameState` Hook进行集中管理，其内部通过`useReducer`维护一个复杂的状态对象（`state`）。该状态对象清晰地定义了游戏的各个阶段和核心玩法边界。

游戏状态（`gamePhase`）包含四种主要状态：
- **READY**：游戏准备就绪，等待开始。
- **PLAYING**：游戏正在进行中，玩家可以正常落子。
- **PAUSED**：游戏暂停，通常用于处理技能选择或反制等交互。
- **ENDED**：游戏结束，胜负已分。

状态的流转通过分发（dispatch）不同的Action来驱动。例如，`START_GAME`动作启动游戏，`PLACE_PIECE`动作处理落子并可能触发`SET_WINNER`动作来结束游戏。这种基于状态机的管理模式确保了游戏逻辑的清晰和可预测性，开发者可以通过观察状态的变化来理解游戏的当前进程。

**Section sources**
- [useGameState.js](file://src/hooks/useGameState.js#L88-L94)
- [useGameState.js](file://src/hooks/useGameState.js#L107-L120)
- [useGameState.js](file://src/hooks/useGameState.js#L510-L548)

## 棋盘操作与辅助函数

`gameUtils.js`文件是游戏逻辑的基石，它提供了一系列纯函数来规范棋盘操作。这些函数被`useGameState`和其他组件广泛调用，确保了代码的复用性和一致性。

关键的辅助函数包括：
- `createEmptyBoard`：创建新的空棋盘。
- `cloneBoard`：深拷贝当前棋盘状态，用于在不修改原状态的情况下进行模拟或计算。
- `checkWin`：在每次落子后，检查该位置是否形成了五子连线，是判定胜负的核心函数。
- `isValidPosition` 和 `isEmptyPosition`：用于落子前的合法性校验。
- `getEmptyPositions` 和 `getPlayerPieces`：获取棋盘上所有空位或特定玩家的棋子位置，常用于AI决策。

这些函数的设计遵循了函数式编程原则，它们只依赖于输入参数，不产生副作用，使得游戏逻辑更易于测试和维护。

**Section sources**
- [gameUtils.js](file://src/utils/gameUtils.js#L10-L259)
- [useGameState.js](file://src/hooks/useGameState.js#L6-L8)